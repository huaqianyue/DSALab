[
  {
    "id": "1SequentialList1",
    "shortDescription": "顺序表1：删除并返回最小值",
    "fullDescription": "利用顺序表的操作，实现以下的函数：从顺序表中删除具有最小值的元素并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。\n\n**测试示例：**\n\n示例1：正常删除最小值\n输入：顺序表[3, 1, 4, 2, 5]，长度5\n输出：删除的最小值: 1，结果顺序表: [3, 5, 4, 2]，长度4\n\n示例2：单元素顺序表\n输入：顺序表[7]，长度1\n输出：删除的最小值: 7，结果顺序表: []，长度0",
    "functionSignature": "int deleteMin(SqList &L)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nint deleteMin(SqList &L) {\n    // 如果顺序表为空，应打印错误信息到终端并返回错误码-1\n    \n    // 删除最小值元素，用最后一个元素填补空位\n    // 返回被删除的最小值\n    \n    // 你的代码在这里\n    \n    // 实际的实现应该覆盖这个返回值\n    return 0; \n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList L1, L2, L3;\n    InitList(L1);\n    InitList(L2);\n    InitList(L3);\n    \n    // 测试用例1：正常删除最小值\n    cout << \"=== 测试用例1：正常删除最小值 ===\" << endl;\n    L1.data[0] = 3; L1.data[1] = 1; L1.data[2] = 4; L1.data[3] = 2; L1.data[4] = 5;\n    L1.length = 5;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl;\n    \n    int min_val1 = deleteMin(L1);\n    cout << \"删除的最小值: \" << min_val1 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl << endl;\n    \n    // 测试用例2：单元素顺序表\n    cout << \"=== 测试用例2：单元素顺序表 ===\" << endl;\n    L2.data[0] = 7;\n    L2.length = 1;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    \n    int min_val2 = deleteMin(L2);\n    cout << \"删除的最小值: \" << min_val2 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl << endl;\n    \n    // 测试用例3：空顺序表处理\n    cout << \"=== 测试用例3：空顺序表处理 ===\" << endl;\n    L3.length = 0; // 空顺序表\n    \n    cout << \"原始顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    \n    int min_val3 = deleteMin(L3);\n    cout << \"尝试删除最小值，返回码: \" << min_val3 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\n// 修改 runTest 函数签名，移除 shouldFail\nTestResult runTest(const string& testName, int inputArr[], int inputLen, int expectedMin, int expectedArr[], int expectedLen) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList testList = createList(inputArr, inputLen);\n    SqList originalList = createList(inputArr, inputLen); // 保存原始状态，用于错误处理检测\n    SqList expectedList = createList(expectedArr, expectedLen);\n    \n    int actualMin = 0;\n    try {\n        actualMin = deleteMin(testList);\n        \n        // 特殊处理空列表的错误情况\n        if (inputLen == 0) {\n            bool statusCorrect = (actualMin == expectedMin); // 期望的 min_val 为 -1\n            bool listUnchanged = compareLists(testList, originalList); // 列表应该保持不变\n\n            if (statusCorrect && listUnchanged) {\n                cout << \"[PASS] \" << testName << \" - 空顺序表错误处理正确\" << endl;\n                return {true, \"空顺序表错误处理正确\"};\n            } else {\n                cout << \"[FAIL] \" << testName << \" - 空顺序表错误处理不正确\";\n                if (!statusCorrect) cout << \" (错误码: 期望\" << expectedMin << \", 实际\" << actualMin << \")\";\n                if (!listUnchanged) cout << \" (列表被意外修改)\";\n                cout << endl;\n                return {false, \"空顺序表错误处理不正确\"};\n            }\n        }\n        \n        // 改进的空函数检测：如果列表内容和长度都没有改变，且输入列表非空，则认为是空实现\n        if (compareLists(testList, originalList) && inputLen > 0) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现 (列表未改变)\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool minCorrect = (actualMin == expectedMin);\n        bool listCorrect = compareLists(testList, expectedList);\n        bool passed = minCorrect && listCorrect;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!minCorrect) cout << \" - 最小值错误: 期望\" << expectedMin << \", 实际\" << actualMin;\n            if (!listCorrect) cout << \" - 结果顺序表错误\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常删除最小值\n    int input1[] = {3, 1, 4, 2, 5};\n    int expected1[] = {3, 5, 4, 2};\n    results.push_back(runTest(\"正常删除最小值\", input1, 5, 1, expected1, 4));\n    \n    // 测试用例2：单元素顺序表\n    int input2[] = {7};\n    int expected2[] = {};\n    results.push_back(runTest(\"单元素顺序表\", input2, 1, 7, expected2, 0));\n    \n    // 测试用例3：空顺序表处理 (期望返回错误码-1)\n    int input3[] = {};\n    int expected3[] = {}; // 结果列表内容不重要，因为是错误情况\n    results.push_back(runTest(\"空顺序表处理\", input3, 0, -1, expected3, 0));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList2",
    "shortDescription": "顺序表2：插入元素x到第i个位置",
    "fullDescription": "向顺序表中第i个位置插入一个新的元素x。如果i不合理则显示出错信息并退出运行。\n\n**测试示例：**\n\n示例1：中间插入\n输入：顺序表[1, 3, 5]，长度3，插入元素2到位置1\n输出：插入后顺序表: [1, 2, 3, 5]，长度4\n\n示例2：末尾插入\n输入：顺序表[1, 2]，长度2，插入元素3到位置2\n输出：插入后顺序表: [1, 2, 3]，长度3",
    "functionSignature": "Status ListInsert(SqList &L, int i, ElemType e)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nStatus ListInsert(SqList &L, int i, ElemType e) {\n    // 如果i不在合理范围或顺序表已满，应打印错误信息到终端并返回错误码-1\n    \n    // 在第i个位置插入元素e（注意：i从1开始计数）\n    \n    // 你的代码在这里\n    \n    // 实际的实现应该覆盖这个返回值\n    return 0; \n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList L1, L2, L3, L4;\n    InitList(L1);\n    InitList(L2);\n    InitList(L3);\n    InitList(L4);\n    \n    // 测试用例1：中间插入\n    cout << \"=== 测试用例1：中间插入 ===\" << endl;\n    L1.data[0] = 1; L1.data[1] = 3; L1.data[2] = 5;\n    L1.length = 3;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl;\n    cout << \"插入元素2到位置2（第2个位置）\" << endl;\n    \n    Status s1 = ListInsert(L1, 2, 2);\n    cout << \"插入状态码: \" << s1 << endl;\n    cout << \"插入后顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl << endl;\n    \n    // 测试用例2：末尾插入\n    cout << \"=== 测试用例2：末尾插入 ===\" << endl;\n    L2.data[0] = 1; L2.data[1] = 2;\n    L2.length = 2;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    cout << \"插入元素3到位置3（末尾位置）\" << endl;\n    \n    Status s2 = ListInsert(L2, 3, 3);\n    cout << \"插入状态码: \" << s2 << endl;\n    cout << \"插入后顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl << endl;\n    \n    // 测试用例3：无效位置处理\n    cout << \"=== 测试用例3：无效位置处理 ===\" << endl;\n    L3.data[0] = 1; L3.data[1] = 2;\n    L3.length = 2;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    cout << \"尝试插入元素5到位置10\" << endl;\n    \n    Status s3 = ListInsert(L3, 10, 5);\n    cout << \"插入状态码: \" << s3 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\n// 修改 runTest 函数签名，移除 shouldFail，添加 expectedStatus\nTestResult runTest(const string& testName, int inputArr[], int inputLen, int pos, int elem, int expectedArr[], int expectedLen, Status expectedStatus = 0) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList testList = createList(inputArr, inputLen);\n    SqList originalList = createList(inputArr, inputLen); // 保存原始状态，用于错误处理检测\n    SqList expectedList = createList(expectedArr, expectedLen);\n    \n    Status actualStatus = 0; // 存储 ListInsert 的实际返回值\n    try {\n        actualStatus = ListInsert(testList, pos, elem);\n        \n        // 特殊处理错误情况 (无效位置或列表已满)\n        if (expectedStatus != 0) { // 如果预期状态不是成功 (0)，则这是一个错误测试用例\n            bool statusCorrect = (actualStatus == expectedStatus);\n            bool listUnchanged = compareLists(testList, originalList); // 列表应该保持不变\n\n            if (statusCorrect && listUnchanged) {\n                cout << \"[PASS] \" << testName << \" - 错误处理正确\" << endl;\n                return {true, \"错误处理正确\"};\n            } else {\n                cout << \"[FAIL] \" << testName << \" - 错误处理不正确\";\n                if (!statusCorrect) cout << \" (错误码: 期望\" << expectedStatus << \", 实际\" << actualStatus << \")\";\n                if (!listUnchanged) cout << \" (列表被意外修改)\";\n                cout << endl;\n                return {false, \"错误处理不正确\"};\n            }\n        }\n        \n        // 检查是否为空实现：如果列表内容和长度都没有改变，则认为是空实现\n        // 仅在非错误情况下进行此检测\n        if (compareLists(testList, originalList)) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现 (列表未改变)\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool listContentCorrect = compareLists(testList, expectedList);\n        bool statusCorrect = (actualStatus == expectedStatus); // 检查成功状态码\n        bool passed = listContentCorrect && statusCorrect;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!statusCorrect) cout << \" - 返回状态错误: 期望\" << expectedStatus << \", 实际\" << actualStatus;\n            if (!listContentCorrect) cout << \" - 结果顺序表不正确\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：中间插入\n    int input1[] = {1, 3, 5};\n    int expected1[] = {1, 2, 3, 5};\n    results.push_back(runTest(\"中间插入\", input1, 3, 2, 2, expected1, 4, 0)); // 期望状态0 (成功)\n    \n    // 测试用例2：末尾插入\n    int input2[] = {1, 2};\n    int expected2[] = {1, 2, 3};\n    results.push_back(runTest(\"末尾插入\", input2, 2, 3, 3, expected2, 3, 0)); // 期望状态0 (成功)\n    \n    // 测试用例3：开头插入\n    int input3[] = {2, 3};\n    int expected3[] = {1, 2, 3};\n    results.push_back(runTest(\"开头插入\", input3, 2, 1, 1, expected3, 3, 0)); // 期望状态0 (成功)\n    \n    // 测试用例4：无效位置处理 (期望返回错误码-1)\n    int input4[] = {1, 2};\n    int expected4[] = {}; // 结果列表内容不重要\n    results.push_back(runTest(\"无效位置处理\", input4, 2, 10, 5, expected4, 0, -1)); // 期望状态-1 (无效位置/列表已满)\n    \n    // 测试用例5：顺序表已满处理 (期望返回错误码-1)\n    int input5[MaxSize];\n    for(int i=0; i<MaxSize; ++i) input5[i] = i+1; // 填充满列表\n    int expected5[] = {}; // 结果列表内容不重要\n    results.push_back(runTest(\"顺序表已满处理\", input5, MaxSize, MaxSize+1, 99, expected5, 0, -1)); // 期望状态-1 (无效位置/列表已满)\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList3",
    "shortDescription": "顺序表3：合并两个有序顺序表",
    "fullDescription": "将两个有序顺序表合并成一个新的有序顺序表并由函数返回结果顺序表。\n\n**测试示例：**\n\n示例1：正常合并\n输入：顺序表A[1, 3, 5]（长度3），顺序表B[2, 4, 6]（长度3）\n输出：合并结果顺序表C[1, 2, 3, 4, 5, 6]（长度6）\n\n示例2：一个为空\n输入：顺序表A[1, 3]（长度2），顺序表B[]（长度0）\n输出：合并结果顺序表C[1, 3]（长度2）",
    "functionSignature": "SqList MergeSortedList(SqList LA, SqList LB)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nSqList MergeSortedList(SqList LA, SqList LB) {\n    // 将两个有序顺序表LA和LB合并成一个新的有序顺序表LC\n    // 要求：LA和LB都是非递减有序的，合并后的LC也应该是非递减有序的\n    // 返回合并后的结果顺序表\n    \n    // 你的代码在这里\n    SqList LC;\n    InitList(LC);\n    \n    \n    return LC;\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList LA, LB, LC;\n    InitList(LA);\n    InitList(LB);\n    \n    // 测试用例1：正常合并\n    cout << \"=== 测试用例1：正常合并 ===\" << endl;\n    LA.data[0] = 1; LA.data[1] = 3; LA.data[2] = 5;\n    LA.length = 3;\n    LB.data[0] = 2; LB.data[1] = 4; LB.data[2] = 6;\n    LB.length = 3;\n    \n    cout << \"顺序表A: \";\n    PrintList(LA);\n    cout << \"，长度: \" << LA.length << endl;\n    cout << \"顺序表B: \";\n    PrintList(LB);\n    cout << \"，长度: \" << LB.length << endl;\n    \n    LC = MergeSortedList(LA, LB);\n    cout << \"合并结果: \";\n    PrintList(LC);\n    cout << \"，长度: \" << LC.length << endl << endl;\n    \n    // 测试用例2：一个为空\n    cout << \"=== 测试用例2：一个为空 ===\" << endl;\n    SqList LA2, LB2, LC2;\n    InitList(LA2);\n    InitList(LB2);\n    \n    LA2.data[0] = 1; LA2.data[1] = 3;\n    LA2.length = 2;\n    LB2.length = 0; // 空顺序表\n    \n    cout << \"顺序表A: \";\n    PrintList(LA2);\n    cout << \"，长度: \" << LA2.length << endl;\n    cout << \"顺序表B: \";\n    PrintList(LB2);\n    cout << \"，长度: \" << LB2.length << endl;\n    \n    LC2 = MergeSortedList(LA2, LB2);\n    cout << \"合并结果: \";\n    PrintList(LC2);\n    cout << \"，长度: \" << LC2.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 检查顺序表是否有序\nbool isSorted(SqList L) {\n    for (int i = 1; i < L.length; i++) {\n        if (L.data[i] < L.data[i-1]) return false;\n    }\n    return true;\n}\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\nTestResult runTest(const string& testName, int arr1[], int len1, int arr2[], int len2, int expectedArr[], int expectedLen) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList LA = createList(arr1, len1);\n    SqList LB = createList(arr2, len2);\n    SqList expected = createList(expectedArr, expectedLen);\n    \n    try {\n        SqList result = MergeSortedList(LA, LB);\n        \n        // 检查是否为空实现（返回空顺序表且输入不全为空）\n        if (result.length == 0 && (len1 > 0 || len2 > 0)) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool lengthCorrect = (result.length == expectedLen);\n        bool contentCorrect = compareLists(result, expected);\n        bool sorted = isSorted(result);\n        bool passed = lengthCorrect && contentCorrect && sorted;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!sorted) cout << \" - 结果不是有序的\";\n            if (!lengthCorrect) cout << \" - 长度错误: 期望\" << expectedLen << \", 实际\" << result.length;\n            if (!contentCorrect) cout << \" - 内容不正确\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常合并\n    int input1A[] = {1, 3, 5};\n    int input1B[] = {2, 4, 6};\n    int expected1[] = {1, 2, 3, 4, 5, 6};\n    results.push_back(runTest(\"正常合并\", input1A, 3, input1B, 3, expected1, 6));\n    \n    // 测试用例2：一个为空\n    int input2A[] = {1, 3};\n    int input2B[] = {};\n    int expected2[] = {1, 3};\n    results.push_back(runTest(\"一个为空\", input2A, 2, input2B, 0, expected2, 2));\n    \n    // 测试用例3：包含重复元素\n    int input3A[] = {1, 2, 3};\n    int input3B[] = {2, 3, 4};\n    int expected3[] = {1, 2, 2, 3, 3, 4};\n    results.push_back(runTest(\"包含重复元素\", input3A, 3, input3B, 3, expected3, 6));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "2String1",
    "shortDescription": "字符串1：按分隔符拆分字符串",
    "fullDescription": "给你一个字符串数组 `words` 和一个字符 `separator` ，请你按 `separator` 拆分 `words` 中的每个字符串。返回一个由拆分后的新字符串组成的字符串数组，**不包括空字符串**。\n\n**注意：**\n- `separator` 用于决定拆分发生的位置，但它不包含在结果字符串中。\n- 拆分可能形成两个以上的字符串。\n- 结果字符串必须保持初始相同的先后顺序。\n\n**示例 1：**\n输入：words = [\"one.two.three\",\"four.five\",\"six\"], separator = '.'\n输出：[\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]\n\n**示例 2：**\n输入：words = [\"$easy$\",\"$problem$\"], separator = '$'\n输出：[\"easy\",\"problem\"]\n\n**示例 3：**\n输入：words = [\"|||\"], separator = '|'\n输出：[]",
    "functionSignature": "vector<string> splitWordsBySeparator(vector<string>& words, char separator)",
    "studentDebugTemplate": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// 打印字符串数组\nvoid printStringVector(const vector<string>& vec) {\n    cout << \"[\";\n    for (int i = 0; i < vec.size(); i++) {\n        cout << \"\\\"\" << vec[i] << \"\\\"\";\n        if (i < vec.size() - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nvector<string> splitWordsBySeparator(vector<string>& words, char separator) {\n    // 按分隔符拆分字符串数组中的每个字符串\n    // 不包括空字符串\n    // 保持原有顺序\n    \n    // 你的代码在这里\n    vector<string> result;\n    \n    return result;\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    // 测试用例1：正常拆分\n    cout << \"=== 测试用例1：正常拆分 ===\" << endl;\n    vector<string> words1 = {\"one.two.three\", \"four.five\", \"six\"};\n    cout << \"输入: \";\n    printStringVector(words1);\n    cout << \", separator = '.'\" << endl;\n    \n    vector<string> result1 = splitWordsBySeparator(words1, '.');\n    cout << \"输出: \";\n    printStringVector(result1);\n    cout << endl << endl;\n    \n    // 测试用例2：过滤空字符串\n    cout << \"=== 测试用例2：过滤空字符串 ===\" << endl;\n    vector<string> words2 = {\"$easy$\", \"$problem$\"};\n    cout << \"输入: \";\n    printStringVector(words2);\n    cout << \", separator = '$'\" << endl;\n    \n    vector<string> result2 = splitWordsBySeparator(words2, '$');\n    cout << \"输出: \";\n    printStringVector(result2);\n    cout << endl << endl;\n    \n    // 测试用例3：全是分隔符\n    cout << \"=== 测试用例3：全是分隔符 ===\" << endl;\n    vector<string> words3 = {\"|||\"};\n    cout << \"输入: \";\n    printStringVector(words3);\n    cout << \", separator = '|'\" << endl;\n    \n    vector<string> result3 = splitWordsBySeparator(words3, '|');\n    cout << \"输出: \";\n    printStringVector(result3);\n    cout << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 比较两个字符串向量是否相等\nbool compareVectors(const vector<string>& v1, const vector<string>& v2) {\n    if (v1.size() != v2.size()) return false;\n    for (int i = 0; i < v1.size(); i++) {\n        if (v1[i] != v2[i]) return false;\n    }\n    return true;\n}\n\nTestResult runTest(const string& testName, vector<string> words, char separator, const vector<string>& expected) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    try {\n        vector<string> result = splitWordsBySeparator(words, separator);\n        \n        bool passed = compareVectors(result, expected);\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName << \" - 结果不正确\" << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常拆分\n    results.push_back(runTest(\"正常拆分\", \n        {\"one.two.three\", \"four.five\", \"six\"}, '.', \n        {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    \n    // 测试用例2：过滤空字符串\n    results.push_back(runTest(\"过滤空字符串\", \n        {\"$easy$\", \"$problem$\"}, '$', \n        {\"easy\", \"problem\"}));\n    \n    // 测试用例3：全是分隔符\n    results.push_back(runTest(\"全是分隔符\", \n        {\"|||\"}, '|', \n        {}));\n    \n    // 测试用例4：无分隔符\n    results.push_back(runTest(\"无分隔符\", \n        {\"hello\", \"world\"}, '.', \n        {\"hello\", \"world\"}));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n        cout << \"提示: 检测到可能的空函数实现，请确保已完成函数代码\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "2String2",
    "shortDescription": "字符串2：最大重复子字符串",
    "fullDescription": "给你一个字符串 `sequence` 和 `word`，如果字符串 `word` 连续重复 `k` 次形成的字符串是 `sequence` 的一个子字符串，那么单词 `word` 的 **重复值为 k**。单词 `word` 的 **最大重复值** 是单词 `word` 在 `sequence` 中最大的重复值。如果 `word` 不是 `sequence` 的子串，那么重复值 `k` 为 `0`。\n\n请你返回 **最大重复值 k**。\n\n**示例 1：**\n输入：sequence = \"ababc\", word = \"ab\"\n输出：2\n解释：\"abab\" 是 \"ababc\" 的子字符串。\n\n**示例 2：**\n输入：sequence = \"ababc\", word = \"ba\"\n输出：1\n解释：\"ba\" 是 \"ababc\" 的子字符串，但 \"baba\" 不是。\n\n**示例 3：**\n输入：sequence = \"ababc\", word = \"ac\"\n输出：0\n解释：\"ac\" 不是 \"ababc\" 的子字符串。",
    "functionSignature": "int maxRepeating(string sequence, string word)",
    "studentDebugTemplate": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// TODO: 实现这个函数\nint maxRepeating(string sequence, string word) {\n    // 返回 word 在 sequence 中的最大连续重复次数\n    // 如果 word 不是 sequence 的子串，返回 0\n    \n    // 你的代码在这里\n    \n    return 0;\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    // 测试用例1：正常重复\n    cout << \"=== 测试用例1：正常重复 ===\" << endl;\n    string seq1 = \"ababc\";\n    string word1 = \"ab\";\n    cout << \"sequence = \\\"\" << seq1 << \"\\\", word = \\\"\" << word1 << \"\\\"\" << endl;\n    int result1 = maxRepeating(seq1, word1);\n    cout << \"输出: \" << result1 << endl << endl;\n    \n    // 测试用例2：单次出现\n    cout << \"=== 测试用例2：单次出现 ===\" << endl;\n    string seq2 = \"ababc\";\n    string word2 = \"ba\";\n    cout << \"sequence = \\\"\" << seq2 << \"\\\", word = \\\"\" << word2 << \"\\\"\" << endl;\n    int result2 = maxRepeating(seq2, word2);\n    cout << \"输出: \" << result2 << endl << endl;\n    \n    // 测试用例3：不存在\n    cout << \"=== 测试用例3：不存在 ===\" << endl;\n    string seq3 = \"ababc\";\n    string word3 = \"ac\";\n    cout << \"sequence = \\\"\" << seq3 << \"\\\", word = \\\"\" << word3 << \"\\\"\" << endl;\n    int result3 = maxRepeating(seq3, word3);\n    cout << \"输出: \" << result3 << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\nTestResult runTest(const string& testName, const string& sequence, const string& word, int expected) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    try {\n        int result = maxRepeating(sequence, word);\n        \n        bool passed = (result == expected);\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName << \" - 期望: \" << expected << \", 实际: \" << result << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常重复2次\n    results.push_back(runTest(\"正常重复2次\", \"ababc\", \"ab\", 2));\n    \n    // 测试用例2：单次出现\n    results.push_back(runTest(\"单次出现\", \"ababc\", \"ba\", 1));\n    \n    // 测试用例3：不存在\n    results.push_back(runTest(\"不存在\", \"ababc\", \"ac\", 0));\n    \n    // 测试用例4：重复多次\n    results.push_back(runTest(\"重复多次\", \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\", \"aaaba\", 5));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n        cout << \"提示: 检测到可能的空函数实现，请确保已完成函数代码\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "2String3",
    "shortDescription": "字符串3：最长回文子串",
    "fullDescription": "给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n**回文串** 是正着读和反着读都一样的字符串。\n\n**示例 1：**\n输入：s = \"babad\"\n输出：\"bab\" 或 \"aba\"\n解释：\"aba\" 同样是符合题意的答案。\n\n**示例 2：**\n输入：s = \"cbbd\"\n输出：\"bb\"\n\n**示例 3：**\n输入：s = \"a\"\n输出：\"a\"\n\n**示例 4：**\n输入：s = \"ac\"\n输出：\"a\" 或 \"c\"",
    "functionSignature": "string longestPalindrome(string s)",
    "studentDebugTemplate": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// TODO: 实现这个函数\nstring longestPalindrome(string s) {\n    // 找到字符串 s 中最长的回文子串\n    // 提示：可以使用中心扩展法\n    // 需要考虑奇数长度和偶数长度的回文串\n    \n    // 你的代码在这里\n    \n    return \"\";\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    // 测试用例1：奇数长度回文\n    cout << \"=== 测试用例1：奇数长度回文 ===\" << endl;\n    string s1 = \"babad\";\n    cout << \"输入: \\\"\" << s1 << \"\\\"\" << endl;\n    string result1 = longestPalindrome(s1);\n    cout << \"输出: \\\"\" << result1 << \"\\\"\" << endl << endl;\n    \n    // 测试用例2：偶数长度回文\n    cout << \"=== 测试用例2：偶数长度回文 ===\" << endl;\n    string s2 = \"cbbd\";\n    cout << \"输入: \\\"\" << s2 << \"\\\"\" << endl;\n    string result2 = longestPalindrome(s2);\n    cout << \"输出: \\\"\" << result2 << \"\\\"\" << endl << endl;\n    \n    // 测试用例3：单字符\n    cout << \"=== 测试用例3：单字符 ===\" << endl;\n    string s3 = \"a\";\n    cout << \"输入: \\\"\" << s3 << \"\\\"\" << endl;\n    string result3 = longestPalindrome(s3);\n    cout << \"输出: \\\"\" << result3 << \"\\\"\" << endl << endl;\n    \n    // 测试用例4：无长回文\n    cout << \"=== 测试用例4：无长回文 ===\" << endl;\n    string s4 = \"ac\";\n    cout << \"输入: \\\"\" << s4 << \"\\\"\" << endl;\n    string result4 = longestPalindrome(s4);\n    cout << \"输出: \\\"\" << result4 << \"\\\"\" << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 检查字符串是否是回文\nbool isPalindrome(const string& s) {\n    int left = 0, right = s.length() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}\n\n// 检查结果是否有效（是回文且长度正确）\nbool isValidResult(const string& s, const string& result, int expectedLen) {\n    // 检查结果是否是原字符串的子串\n    if (s.find(result) == string::npos) return false;\n    \n    // 检查结果是否是回文\n    if (!isPalindrome(result)) return false;\n    \n    // 检查长度是否正确\n    if (result.length() != expectedLen) return false;\n    \n    return true;\n}\n\nTestResult runTest(const string& testName, const string& s, int expectedLen) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    try {\n        string result = longestPalindrome(s);\n        \n        // 检查是否为空实现\n        if (result.empty() && !s.empty()) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool valid = isValidResult(s, result, expectedLen);\n        \n        if (valid) {\n            cout << \"[PASS] \" << testName << \" - 结果: \\\"\" << result << \"\\\"\" << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName << \" - 结果不正确或不是回文: \\\"\" << result << \"\\\"\" << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：babad（最长回文长度为3）\n    results.push_back(runTest(\"奇数长度回文\", \"babad\", 3));\n    \n    // 测试用例2：cbbd（最长回文长度为2）\n    results.push_back(runTest(\"偶数长度回文\", \"cbbd\", 2));\n    \n    // 测试用例3：单字符\n    results.push_back(runTest(\"单字符\", \"a\", 1));\n    \n    // 测试用例4：ac（最长回文长度为1）\n    results.push_back(runTest(\"无长回文\", \"ac\", 1));\n    \n    // 测试用例5：较长回文\n    results.push_back(runTest(\"较长回文\", \"bananas\", 5)); // \"anana\"\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n        cout << \"提示: 检测到可能的空函数实现，请确保已完成函数代码\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "2String4",
    "shortDescription": "字符串4：无重复字符的最长子串",
    "fullDescription": "给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**子串** 是字符串中连续的字符序列。\n\n**示例 1：**\n输入：s = \"abcabcbb\"\n输出：3\n解释：因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n**示例 2：**\n输入：s = \"bbbbb\"\n输出：1\n解释：因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n**示例 3：**\n输入：s = \"pwwkew\"\n输出：3\n解释：因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。注意，答案必须是子串的长度，\"pwke\" 是一个子序列，不是子串。\n\n**示例 4：**\n输入：s = \"\"\n输出：0",
    "functionSignature": "int lengthOfLongestSubstring(string s)",
    "studentDebugTemplate": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// TODO: 实现这个函数\nint lengthOfLongestSubstring(string s) {\n    // 找出字符串中不含重复字符的最长子串的长度\n    // 提示：可以使用滑动窗口法\n    \n    // 你的代码在这里\n    \n    return 0;\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    // 测试用例1：正常情况\n    cout << \"=== 测试用例1：正常情况 ===\" << endl;\n    string s1 = \"abcabcbb\";\n    cout << \"输入: \\\"\" << s1 << \"\\\"\" << endl;\n    int result1 = lengthOfLongestSubstring(s1);\n    cout << \"输出: \" << result1 << endl << endl;\n    \n    // 测试用例2：全部重复\n    cout << \"=== 测试用例2：全部重复 ===\" << endl;\n    string s2 = \"bbbbb\";\n    cout << \"输入: \\\"\" << s2 << \"\\\"\" << endl;\n    int result2 = lengthOfLongestSubstring(s2);\n    cout << \"输出: \" << result2 << endl << endl;\n    \n    // 测试用例3：部分重复\n    cout << \"=== 测试用例3：部分重复 ===\" << endl;\n    string s3 = \"pwwkew\";\n    cout << \"输入: \\\"\" << s3 << \"\\\"\" << endl;\n    int result3 = lengthOfLongestSubstring(s3);\n    cout << \"输出: \" << result3 << endl << endl;\n    \n    // 测试用例4：空字符串\n    cout << \"=== 测试用例4：空字符串 ===\" << endl;\n    string s4 = \"\";\n    cout << \"输入: \\\"\" << s4 << \"\\\"\" << endl;\n    int result4 = lengthOfLongestSubstring(s4);\n    cout << \"输出: \" << result4 << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\nTestResult runTest(const string& testName, const string& s, int expected) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    try {\n        int result = lengthOfLongestSubstring(s);\n        \n        bool passed = (result == expected);\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName << \" - 期望: \" << expected << \", 实际: \" << result << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常情况\n    results.push_back(runTest(\"正常情况\", \"abcabcbb\", 3));\n    \n    // 测试用例2：全部重复\n    results.push_back(runTest(\"全部重复\", \"bbbbb\", 1));\n    \n    // 测试用例3：部分重复\n    results.push_back(runTest(\"部分重复\", \"pwwkew\", 3));\n    \n    // 测试用例4：空字符串\n    results.push_back(runTest(\"空字符串\", \"\", 0));\n    \n    // 测试用例5：无重复\n    results.push_back(runTest(\"无重复\", \"abcdef\", 6));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n        cout << \"提示: 检测到可能的空函数实现，请确保已完成函数代码\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  }
]