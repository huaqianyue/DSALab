[
  {
    "id": "1SequentialList1",
    "shortDescription": "顺序表1：删除并返回最小值",
    "fullDescription": "利用顺序表的操作，实现以下的函数：从顺序表中删除具有最小值的元素并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。\n\n**测试示例：**\n\n示例1：正常删除最小值\n输入：顺序表[3, 1, 4, 2, 5]，长度5\n输出：删除的最小值: 1，结果顺序表: [3, 5, 4, 2]，长度4\n\n示例2：单元素顺序表\n输入：顺序表[7]，长度1\n输出：删除的最小值: 7，结果顺序表: []，长度0",
    "functionSignature": "int deleteMin(SqList &L)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nint deleteMin(SqList &L) {\n    // 如果顺序表为空，应打印错误信息到 cerr 并调用 exit(1)\n    // 删除最小值元素，用最后一个元素填补空位\n    // 返回被删除的最小值\n    \n    // 你的代码在这里\n    \n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList L1, L2;\n    InitList(L1);\n    InitList(L2);\n    \n    // 测试用例1：正常删除最小值\n    cout << \"=== 测试用例1：正常删除最小值 ===\" << endl;\n    L1.data[0] = 3; L1.data[1] = 1; L1.data[2] = 4; L1.data[3] = 2; L1.data[4] = 5;\n    L1.length = 5;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl;\n    \n    int min_val1 = deleteMin(L1);\n    cout << \"删除的最小值: \" << min_val1 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl << endl;\n    \n    // 测试用例2：单元素顺序表\n    cout << \"=== 测试用例2：单元素顺序表 ===\" << endl;\n    L2.data[0] = 7;\n    L2.length = 1;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    \n    int min_val2 = deleteMin(L2);\n    cout << \"删除的最小值: \" << min_val2 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 检查学生函数是否为空实现\nbool isEmptyFunction(const string& functionName) {\n    // 这里简化处理，在实际测试中会通过运行时行为检测\n    return false;\n}\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\nTestResult runTest(const string& testName, int inputArr[], int inputLen, int expectedMin, int expectedArr[], int expectedLen, bool shouldFail = false) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    if (shouldFail) {\n        cout << \"[PASS] 空顺序表错误处理测试\" << endl;\n        return {true, \"空顺序表错误处理正确\"};\n    }\n    \n    SqList testList = createList(inputArr, inputLen);\n    SqList expectedList = createList(expectedArr, expectedLen);\n    \n    try {\n        int actualMin = deleteMin(testList);\n        \n        // 检查是否为空实现（通过返回值和顺序表变化检测）\n        if (actualMin == 0 && testList.length == inputLen) {\n            bool unchanged = true;\n            for (int i = 0; i < inputLen; i++) {\n                if (testList.data[i] != inputArr[i]) {\n                    unchanged = false;\n                    break;\n                }\n            }\n            if (unchanged && inputLen > 0) {\n                cout << \"[FAIL] \" << testName << \" - 检测到空函数实现\" << endl;\n                return {false, \"函数未实现\"};\n            }\n        }\n        \n        bool minCorrect = (actualMin == expectedMin);\n        bool listCorrect = compareLists(testList, expectedList);\n        bool passed = minCorrect && listCorrect;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!minCorrect) cout << \" - 最小值错误: 期望\" << expectedMin << \", 实际\" << actualMin;\n            if (!listCorrect) cout << \" - 结果顺序表错误\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常删除最小值\n    int input1[] = {3, 1, 4, 2, 5};\n    int expected1[] = {3, 5, 4, 2};\n    results.push_back(runTest(\"正常删除最小值\", input1, 5, 1, expected1, 4));\n    \n    // 测试用例2：单元素顺序表\n    int input2[] = {7};\n    int expected2[] = {};\n    results.push_back(runTest(\"单元素顺序表\", input2, 1, 7, expected2, 0));\n    \n    // 测试用例3：空顺序表处理（简化处理）\n    int input3[] = {};\n    int expected3[] = {};\n    results.push_back(runTest(\"空顺序表处理\", input3, 0, 0, expected3, 0, true));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList2",
    "shortDescription": "顺序表2：插入元素x到第i个位置",
    "fullDescription": "向顺序表中第i个位置插入一个新的元素x。如果i不合理则显示出错信息并退出运行。\n\n**测试示例：**\n\n示例1：中间插入\n输入：顺序表[1, 3, 5]，长度3，插入元素2到位置1\n输出：插入后顺序表: [1, 2, 3, 5]，长度4\n\n示例2：末尾插入\n输入：顺序表[1, 2]，长度2，插入元素3到位置2\n输出：插入后顺序表: [1, 2, 3]，长度3",
    "functionSignature": "Status ListInsert(SqList &L, int i, ElemType e)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nStatus ListInsert(SqList &L, int i, ElemType e) {\n    // 如果i不在合理范围[1, L.length+1]内，\n    // 应打印错误信息到 cerr 并调用 exit(1)\n    // 在第i个位置插入元素e（注意：i从1开始计数）\n    // 如果顺序表已满，也应显示错误信息并退出\n    \n    // 你的代码在这里\n    \n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList L1, L2;\n    InitList(L1);\n    InitList(L2);\n    \n    // 测试用例1：中间插入\n    cout << \"=== 测试用例1：中间插入 ===\" << endl;\n    L1.data[0] = 1; L1.data[1] = 3; L1.data[2] = 5;\n    L1.length = 3;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl;\n    cout << \"插入元素2到位置2（第2个位置）\" << endl;\n    \n    ListInsert(L1, 2, 2);\n    cout << \"插入后顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl << endl;\n    \n    // 测试用例2：末尾插入\n    cout << \"=== 测试用例2：末尾插入 ===\" << endl;\n    L2.data[0] = 1; L2.data[1] = 2;\n    L2.length = 2;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    cout << \"插入元素3到位置3（末尾位置）\" << endl;\n    \n    ListInsert(L2, 3, 3);\n    cout << \"插入后顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\nTestResult runTest(const string& testName, int inputArr[], int inputLen, int pos, int elem, int expectedArr[], int expectedLen, bool shouldFail = false) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    if (shouldFail) {\n        cout << \"[PASS] 无效位置错误处理测试\" << endl;\n        return {true, \"无效位置错误处理正确\"};\n    }\n    \n    SqList testList = createList(inputArr, inputLen);\n    SqList expectedList = createList(expectedArr, expectedLen);\n    SqList originalList = createList(inputArr, inputLen);\n    \n    try {\n        Status result = ListInsert(testList, pos, elem);\n        \n        // 检查是否为空实现（通过顺序表变化检测）\n        if (compareLists(testList, originalList)) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool correct = compareLists(testList, expectedList);\n        \n        if (correct) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName << \" - 结果顺序表不正确\" << endl;\n            return {false, \"结果顺序表不正确\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：中间插入\n    int input1[] = {1, 3, 5};\n    int expected1[] = {1, 2, 3, 5};\n    results.push_back(runTest(\"中间插入\", input1, 3, 2, 2, expected1, 4));\n    \n    // 测试用例2：末尾插入\n    int input2[] = {1, 2};\n    int expected2[] = {1, 2, 3};\n    results.push_back(runTest(\"末尾插入\", input2, 2, 3, 3, expected2, 3));\n    \n    // 测试用例3：开头插入\n    int input3[] = {2, 3};\n    int expected3[] = {1, 2, 3};\n    results.push_back(runTest(\"开头插入\", input3, 2, 1, 1, expected3, 3));\n    \n    // 测试用例4：无效位置处理（简化处理）\n    int input4[] = {1, 2};\n    int expected4[] = {};\n    results.push_back(runTest(\"无效位置处理\", input4, 2, 10, 5, expected4, 0, true));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList3",
    "shortDescription": "顺序表3：合并两个有序顺序表",
    "fullDescription": "将两个有序顺序表合并成一个新的有序顺序表并由函数返回结果顺序表。\n\n**测试示例：**\n\n示例1：正常合并\n输入：顺序表A[1, 3, 5]（长度3），顺序表B[2, 4, 6]（长度3）\n输出：合并结果顺序表C[1, 2, 3, 4, 5, 6]（长度6）\n\n示例2：一个为空\n输入：顺序表A[1, 3]（长度2），顺序表B[]（长度0）\n输出：合并结果顺序表C[1, 3]（长度2）",
    "functionSignature": "SqList MergeSortedList(SqList LA, SqList LB)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nSqList MergeSortedList(SqList LA, SqList LB) {\n    // 将两个有序顺序表LA和LB合并成一个新的有序顺序表LC\n    // 要求：LA和LB都是非递减有序的，合并后的LC也应该是非递减有序的\n    // 返回合并后的结果顺序表\n    \n    // 你的代码在这里\n    SqList LC;\n    InitList(LC);\n    \n    \n    return LC;\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList LA, LB, LC;\n    InitList(LA);\n    InitList(LB);\n    \n    // 测试用例1：正常合并\n    cout << \"=== 测试用例1：正常合并 ===\" << endl;\n    LA.data[0] = 1; LA.data[1] = 3; LA.data[2] = 5;\n    LA.length = 3;\n    LB.data[0] = 2; LB.data[1] = 4; LB.data[2] = 6;\n    LB.length = 3;\n    \n    cout << \"顺序表A: \";\n    PrintList(LA);\n    cout << \"，长度: \" << LA.length << endl;\n    cout << \"顺序表B: \";\n    PrintList(LB);\n    cout << \"，长度: \" << LB.length << endl;\n    \n    LC = MergeSortedList(LA, LB);\n    cout << \"合并结果: \";\n    PrintList(LC);\n    cout << \"，长度: \" << LC.length << endl << endl;\n    \n    // 测试用例2：一个为空\n    cout << \"=== 测试用例2：一个为空 ===\" << endl;\n    SqList LA2, LB2, LC2;\n    InitList(LA2);\n    InitList(LB2);\n    \n    LA2.data[0] = 1; LA2.data[1] = 3;\n    LA2.length = 2;\n    LB2.length = 0; // 空顺序表\n    \n    cout << \"顺序表A: \";\n    PrintList(LA2);\n    cout << \"，长度: \" << LA2.length << endl;\n    cout << \"顺序表B: \";\n    PrintList(LB2);\n    cout << \"，长度: \" << LB2.length << endl;\n    \n    LC2 = MergeSortedList(LA2, LB2);\n    cout << \"合并结果: \";\n    PrintList(LC2);\n    cout << \"，长度: \" << LC2.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 检查顺序表是否有序\nbool isSorted(SqList L) {\n    for (int i = 1; i < L.length; i++) {\n        if (L.data[i] < L.data[i-1]) return false;\n    }\n    return true;\n}\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\nTestResult runTest(const string& testName, int arr1[], int len1, int arr2[], int len2, int expectedArr[], int expectedLen) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList LA = createList(arr1, len1);\n    SqList LB = createList(arr2, len2);\n    SqList expected = createList(expectedArr, expectedLen);\n    \n    try {\n        SqList result = MergeSortedList(LA, LB);\n        \n        // 检查是否为空实现（返回空顺序表且输入不全为空）\n        if (result.length == 0 && (len1 > 0 || len2 > 0)) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool lengthCorrect = (result.length == expectedLen);\n        bool contentCorrect = compareLists(result, expected);\n        bool sorted = isSorted(result);\n        bool passed = lengthCorrect && contentCorrect && sorted;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!sorted) cout << \" - 结果不是有序的\";\n            if (!lengthCorrect) cout << \" - 长度错误: 期望\" << expectedLen << \", 实际\" << result.length;\n            if (!contentCorrect) cout << \" - 内容不正确\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常合并\n    int input1A[] = {1, 3, 5};\n    int input1B[] = {2, 4, 6};\n    int expected1[] = {1, 2, 3, 4, 5, 6};\n    results.push_back(runTest(\"正常合并\", input1A, 3, input1B, 3, expected1, 6));\n    \n    // 测试用例2：一个为空\n    int input2A[] = {1, 3};\n    int input2B[] = {};\n    int expected2[] = {1, 3};\n    results.push_back(runTest(\"一个为空\", input2A, 2, input2B, 0, expected2, 2));\n    \n    // 测试用例3：包含重复元素\n    int input3A[] = {1, 2, 3};\n    int input3B[] = {2, 3, 4};\n    int expected3[] = {1, 2, 2, 3, 3, 4};\n    results.push_back(runTest(\"包含重复元素\", input3A, 3, input3B, 3, expected3, 6));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  }
]