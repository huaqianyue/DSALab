[
  {
    "id": "1SequentialList1",
    "shortDescription": "顺序表1：删除并返回最小值",
    "fullDescription": "利用顺序表的操作，实现以下的函数：从顺序表中删除具有最小值的元素并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。\n\n**测试示例：**\n\n示例1：正常删除最小值\n输入：顺序表[3, 1, 4, 2, 5]，长度5\n输出：删除的最小值: 1，结果顺序表: [3, 5, 4, 2]，长度4\n\n示例2：单元素顺序表\n输入：顺序表[7]，长度1\n输出：删除的最小值: 7，结果顺序表: []，长度0",
    "functionSignature": "int deleteMin(SqList &L)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nint deleteMin(SqList &L) {\n    // 如果顺序表为空，应打印错误信息到终端并返回错误码-1\n    \n    // 删除最小值元素，用最后一个元素填补空位\n    // 返回被删除的最小值\n    \n    // 你的代码在这里\n    \n    // 实际的实现应该覆盖这个返回值\n    return 0; \n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList L1, L2, L3;\n    InitList(L1);\n    InitList(L2);\n    InitList(L3);\n    \n    // 测试用例1：正常删除最小值\n    cout << \"=== 测试用例1：正常删除最小值 ===\" << endl;\n    L1.data[0] = 3; L1.data[1] = 1; L1.data[2] = 4; L1.data[3] = 2; L1.data[4] = 5;\n    L1.length = 5;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl;\n    \n    int min_val1 = deleteMin(L1);\n    cout << \"删除的最小值: \" << min_val1 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl << endl;\n    \n    // 测试用例2：单元素顺序表\n    cout << \"=== 测试用例2：单元素顺序表 ===\" << endl;\n    L2.data[0] = 7;\n    L2.length = 1;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    \n    int min_val2 = deleteMin(L2);\n    cout << \"删除的最小值: \" << min_val2 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl << endl;\n    \n    // 测试用例3：空顺序表处理\n    cout << \"=== 测试用例3：空顺序表处理 ===\" << endl;\n    L3.length = 0; // 空顺序表\n    \n    cout << \"原始顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    \n    int min_val3 = deleteMin(L3);\n    cout << \"尝试删除最小值，返回码: \" << min_val3 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\n// 修改 runTest 函数签名，移除 shouldFail\nTestResult runTest(const string& testName, int inputArr[], int inputLen, int expectedMin, int expectedArr[], int expectedLen) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList testList = createList(inputArr, inputLen);\n    SqList originalList = createList(inputArr, inputLen); // 保存原始状态，用于错误处理检测\n    SqList expectedList = createList(expectedArr, expectedLen);\n    \n    int actualMin = 0;\n    try {\n        actualMin = deleteMin(testList);\n        \n        // 特殊处理空列表的错误情况\n        if (inputLen == 0) {\n            bool statusCorrect = (actualMin == expectedMin); // 期望的 min_val 为 -1\n            bool listUnchanged = compareLists(testList, originalList); // 列表应该保持不变\n\n            if (statusCorrect && listUnchanged) {\n                cout << \"[PASS] \" << testName << \" - 空顺序表错误处理正确\" << endl;\n                return {true, \"空顺序表错误处理正确\"};\n            } else {\n                cout << \"[FAIL] \" << testName << \" - 空顺序表错误处理不正确\";\n                if (!statusCorrect) cout << \" (错误码: 期望\" << expectedMin << \", 实际\" << actualMin << \")\";\n                if (!listUnchanged) cout << \" (列表被意外修改)\";\n                cout << endl;\n                return {false, \"空顺序表错误处理不正确\"};\n            }\n        }\n        \n        // 改进的空函数检测：如果列表内容和长度都没有改变，且输入列表非空，则认为是空实现\n        if (compareLists(testList, originalList) && inputLen > 0) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现 (列表未改变)\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool minCorrect = (actualMin == expectedMin);\n        bool listCorrect = compareLists(testList, expectedList);\n        bool passed = minCorrect && listCorrect;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!minCorrect) cout << \" - 最小值错误: 期望\" << expectedMin << \", 实际\" << actualMin;\n            if (!listCorrect) cout << \" - 结果顺序表错误\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常删除最小值\n    int input1[] = {3, 1, 4, 2, 5};\n    int expected1[] = {3, 5, 4, 2};\n    results.push_back(runTest(\"正常删除最小值\", input1, 5, 1, expected1, 4));\n    \n    // 测试用例2：单元素顺序表\n    int input2[] = {7};\n    int expected2[] = {};\n    results.push_back(runTest(\"单元素顺序表\", input2, 1, 7, expected2, 0));\n    \n    // 测试用例3：空顺序表处理 (期望返回错误码-1)\n    int input3[] = {};\n    int expected3[] = {}; // 结果列表内容不重要，因为是错误情况\n    results.push_back(runTest(\"空顺序表处理\", input3, 0, -1, expected3, 0));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList2",
    "shortDescription": "顺序表2：插入元素x到第i个位置",
    "fullDescription": "向顺序表中第i个位置插入一个新的元素x。如果i不合理则显示出错信息并退出运行。\n\n**测试示例：**\n\n示例1：中间插入\n输入：顺序表[1, 3, 5]，长度3，插入元素2到位置1\n输出：插入后顺序表: [1, 2, 3, 5]，长度4\n\n示例2：末尾插入\n输入：顺序表[1, 2]，长度2，插入元素3到位置2\n输出：插入后顺序表: [1, 2, 3]，长度3",
    "functionSignature": "Status ListInsert(SqList &L, int i, ElemType e)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nStatus ListInsert(SqList &L, int i, ElemType e) {\n    // 如果i不在合理范围或顺序表已满，应打印错误信息到终端并返回错误码-1\n    \n    // 在第i个位置插入元素e（注意：i从1开始计数）\n    \n    // 你的代码在这里\n    \n    // 实际的实现应该覆盖这个返回值\n    return 0; \n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList L1, L2, L3, L4;\n    InitList(L1);\n    InitList(L2);\n    InitList(L3);\n    InitList(L4);\n    \n    // 测试用例1：中间插入\n    cout << \"=== 测试用例1：中间插入 ===\" << endl;\n    L1.data[0] = 1; L1.data[1] = 3; L1.data[2] = 5;\n    L1.length = 3;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl;\n    cout << \"插入元素2到位置2（第2个位置）\" << endl;\n    \n    Status s1 = ListInsert(L1, 2, 2);\n    cout << \"插入状态码: \" << s1 << endl;\n    cout << \"插入后顺序表: \";\n    PrintList(L1);\n    cout << \"，长度: \" << L1.length << endl << endl;\n    \n    // 测试用例2：末尾插入\n    cout << \"=== 测试用例2：末尾插入 ===\" << endl;\n    L2.data[0] = 1; L2.data[1] = 2;\n    L2.length = 2;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl;\n    cout << \"插入元素3到位置3（末尾位置）\" << endl;\n    \n    Status s2 = ListInsert(L2, 3, 3);\n    cout << \"插入状态码: \" << s2 << endl;\n    cout << \"插入后顺序表: \";\n    PrintList(L2);\n    cout << \"，长度: \" << L2.length << endl << endl;\n    \n    // 测试用例3：无效位置处理\n    cout << \"=== 测试用例3：无效位置处理 ===\" << endl;\n    L3.data[0] = 1; L3.data[1] = 2;\n    L3.length = 2;\n    \n    cout << \"原始顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    cout << \"尝试插入元素5到位置10\" << endl;\n    \n    Status s3 = ListInsert(L3, 10, 5);\n    cout << \"插入状态码: \" << s3 << endl;\n    cout << \"结果顺序表: \";\n    PrintList(L3);\n    cout << \"，长度: \" << L3.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\n// 修改 runTest 函数签名，移除 shouldFail，添加 expectedStatus\nTestResult runTest(const string& testName, int inputArr[], int inputLen, int pos, int elem, int expectedArr[], int expectedLen, Status expectedStatus = 0) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList testList = createList(inputArr, inputLen);\n    SqList originalList = createList(inputArr, inputLen); // 保存原始状态，用于错误处理检测\n    SqList expectedList = createList(expectedArr, expectedLen);\n    \n    Status actualStatus = 0; // 存储 ListInsert 的实际返回值\n    try {\n        actualStatus = ListInsert(testList, pos, elem);\n        \n        // 特殊处理错误情况 (无效位置或列表已满)\n        if (expectedStatus != 0) { // 如果预期状态不是成功 (0)，则这是一个错误测试用例\n            bool statusCorrect = (actualStatus == expectedStatus);\n            bool listUnchanged = compareLists(testList, originalList); // 列表应该保持不变\n\n            if (statusCorrect && listUnchanged) {\n                cout << \"[PASS] \" << testName << \" - 错误处理正确\" << endl;\n                return {true, \"错误处理正确\"};\n            } else {\n                cout << \"[FAIL] \" << testName << \" - 错误处理不正确\";\n                if (!statusCorrect) cout << \" (错误码: 期望\" << expectedStatus << \", 实际\" << actualStatus << \")\";\n                if (!listUnchanged) cout << \" (列表被意外修改)\";\n                cout << endl;\n                return {false, \"错误处理不正确\"};\n            }\n        }\n        \n        // 检查是否为空实现：如果列表内容和长度都没有改变，则认为是空实现\n        // 仅在非错误情况下进行此检测\n        if (compareLists(testList, originalList)) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现 (列表未改变)\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool listContentCorrect = compareLists(testList, expectedList);\n        bool statusCorrect = (actualStatus == expectedStatus); // 检查成功状态码\n        bool passed = listContentCorrect && statusCorrect;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!statusCorrect) cout << \" - 返回状态错误: 期望\" << expectedStatus << \", 实际\" << actualStatus;\n            if (!listContentCorrect) cout << \" - 结果顺序表不正确\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：中间插入\n    int input1[] = {1, 3, 5};\n    int expected1[] = {1, 2, 3, 5};\n    results.push_back(runTest(\"中间插入\", input1, 3, 2, 2, expected1, 4, 0)); // 期望状态0 (成功)\n    \n    // 测试用例2：末尾插入\n    int input2[] = {1, 2};\n    int expected2[] = {1, 2, 3};\n    results.push_back(runTest(\"末尾插入\", input2, 2, 3, 3, expected2, 3, 0)); // 期望状态0 (成功)\n    \n    // 测试用例3：开头插入\n    int input3[] = {2, 3};\n    int expected3[] = {1, 2, 3};\n    results.push_back(runTest(\"开头插入\", input3, 2, 1, 1, expected3, 3, 0)); // 期望状态0 (成功)\n    \n    // 测试用例4：无效位置处理 (期望返回错误码-1)\n    int input4[] = {1, 2};\n    int expected4[] = {}; // 结果列表内容不重要\n    results.push_back(runTest(\"无效位置处理\", input4, 2, 10, 5, expected4, 0, -1)); // 期望状态-1 (无效位置/列表已满)\n    \n    // 测试用例5：顺序表已满处理 (期望返回错误码-1)\n    int input5[MaxSize];\n    for(int i=0; i<MaxSize; ++i) input5[i] = i+1; // 填充满列表\n    int expected5[] = {}; // 结果列表内容不重要\n    results.push_back(runTest(\"顺序表已满处理\", input5, MaxSize, MaxSize+1, 99, expected5, 0, -1)); // 期望状态-1 (无效位置/列表已满)\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList3",
    "shortDescription": "顺序表3：合并两个有序顺序表",
    "fullDescription": "将两个有序顺序表合并成一个新的有序顺序表并由函数返回结果顺序表。\n\n**测试示例：**\n\n示例1：正常合并\n输入：顺序表A[1, 3, 5]（长度3），顺序表B[2, 4, 6]（长度3）\n输出：合并结果顺序表C[1, 2, 3, 4, 5, 6]（长度6）\n\n示例2：一个为空\n输入：顺序表A[1, 3]（长度2），顺序表B[]（长度0）\n输出：合并结果顺序表C[1, 3]（长度2）",
    "functionSignature": "SqList MergeSortedList(SqList LA, SqList LB)",
    "studentDebugTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n// 打印顺序表\nvoid PrintList(SqList L) {\n    cout << \"[\";\n    for (int i = 0; i < L.length; i++) {\n        cout << L.data[i];\n        if (i < L.length - 1) cout << \", \";\n    }\n    cout << \"]\";\n}\n\n// TODO: 实现这个函数\nSqList MergeSortedList(SqList LA, SqList LB) {\n    // 将两个有序顺序表LA和LB合并成一个新的有序顺序表LC\n    // 要求：LA和LB都是非递减有序的，合并后的LC也应该是非递减有序的\n    // 返回合并后的结果顺序表\n    \n    // 你的代码在这里\n    SqList LC;\n    InitList(LC);\n    \n    \n    return LC;\n}\n\n// 简单的测试主函数，方便你调试\nint main() {\n    SqList LA, LB, LC;\n    InitList(LA);\n    InitList(LB);\n    \n    // 测试用例1：正常合并\n    cout << \"=== 测试用例1：正常合并 ===\" << endl;\n    LA.data[0] = 1; LA.data[1] = 3; LA.data[2] = 5;\n    LA.length = 3;\n    LB.data[0] = 2; LB.data[1] = 4; LB.data[2] = 6;\n    LB.length = 3;\n    \n    cout << \"顺序表A: \";\n    PrintList(LA);\n    cout << \"，长度: \" << LA.length << endl;\n    cout << \"顺序表B: \";\n    PrintList(LB);\n    cout << \"，长度: \" << LB.length << endl;\n    \n    LC = MergeSortedList(LA, LB);\n    cout << \"合并结果: \";\n    PrintList(LC);\n    cout << \"，长度: \" << LC.length << endl << endl;\n    \n    // 测试用例2：一个为空\n    cout << \"=== 测试用例2：一个为空 ===\" << endl;\n    SqList LA2, LB2, LC2;\n    InitList(LA2);\n    InitList(LB2);\n    \n    LA2.data[0] = 1; LA2.data[1] = 3;\n    LA2.length = 2;\n    LB2.length = 0; // 空顺序表\n    \n    cout << \"顺序表A: \";\n    PrintList(LA2);\n    cout << \"，长度: \" << LA2.length << endl;\n    cout << \"顺序表B: \";\n    PrintList(LB2);\n    cout << \"，长度: \" << LB2.length << endl;\n    \n    LC2 = MergeSortedList(LA2, LB2);\n    cout << \"合并结果: \";\n    PrintList(LC2);\n    cout << \"，长度: \" << LC2.length << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define MaxSize 50\ntypedef int ElemType;\ntypedef int Status;\n\n// 顺序表结构定义\ntypedef struct {\n    ElemType data[MaxSize]; // 顺序表元素\n    int length;             // 顺序表当前长度\n} SqList;\n\n// 初始化顺序表函数，构造一个空的顺序表\nStatus InitList(SqList &L) {\n    memset(L.data, 0, sizeof(L.data)); // 初始化数据为0\n    L.length = 0;                      // 初始化长度为0\n    return 0;\n}\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\n// 检查顺序表是否有序\nbool isSorted(SqList L) {\n    for (int i = 1; i < L.length; i++) {\n        if (L.data[i] < L.data[i-1]) return false;\n    }\n    return true;\n}\n\n// 比较两个顺序表是否相等\nbool compareLists(SqList L1, SqList L2) {\n    if (L1.length != L2.length) return false;\n    for (int i = 0; i < L1.length; i++) {\n        if (L1.data[i] != L2.data[i]) return false;\n    }\n    return true;\n}\n\n// 创建顺序表\nSqList createList(int arr[], int len) {\n    SqList L;\n    InitList(L);\n    for (int i = 0; i < len && i < MaxSize; i++) {\n        L.data[i] = arr[i];\n    }\n    L.length = len;\n    return L;\n}\n\nTestResult runTest(const string& testName, int arr1[], int len1, int arr2[], int len2, int expectedArr[], int expectedLen) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    SqList LA = createList(arr1, len1);\n    SqList LB = createList(arr2, len2);\n    SqList expected = createList(expectedArr, expectedLen);\n    \n    try {\n        SqList result = MergeSortedList(LA, LB);\n        \n        // 检查是否为空实现（返回空顺序表且输入不全为空）\n        if (result.length == 0 && (len1 > 0 || len2 > 0)) {\n            cout << \"[FAIL] \" << testName << \" - 检测到空函数实现\" << endl;\n            return {false, \"函数未实现\"};\n        }\n        \n        bool lengthCorrect = (result.length == expectedLen);\n        bool contentCorrect = compareLists(result, expected);\n        bool sorted = isSorted(result);\n        bool passed = lengthCorrect && contentCorrect && sorted;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!sorted) cout << \" - 结果不是有序的\";\n            if (!lengthCorrect) cout << \" - 长度错误: 期望\" << expectedLen << \", 实际\" << result.length;\n            if (!contentCorrect) cout << \" - 内容不正确\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常合并\n    int input1A[] = {1, 3, 5};\n    int input1B[] = {2, 4, 6};\n    int expected1[] = {1, 2, 3, 4, 5, 6};\n    results.push_back(runTest(\"正常合并\", input1A, 3, input1B, 3, expected1, 6));\n    \n    // 测试用例2：一个为空\n    int input2A[] = {1, 3};\n    int input2B[] = {};\n    int expected2[] = {1, 3};\n    results.push_back(runTest(\"一个为空\", input2A, 2, input2B, 0, expected2, 2));\n    \n    // 测试用例3：包含重复元素\n    int input3A[] = {1, 2, 3};\n    int input3B[] = {2, 3, 4};\n    int expected3[] = {1, 2, 2, 3, 3, 4};\n    results.push_back(runTest(\"包含重复元素\", input3A, 3, input3B, 3, expected3, 6));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    \n    // 如果所有测试都失败，很可能是空函数实现\n    if (passed == 0) {\n        cout << \"[SCORE] 0\" << endl;\n    } else {\n        cout << \"[SCORE] \" << (passed * 100 / (int)results.size()) << endl;\n    }\n    \n    return passed == results.size() ? 0 : 1;\n}"
  }
]