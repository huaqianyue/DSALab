[
  {
    "id": "1SequentialList1",
    "shortDescription": "顺序表1：删除并返回最小值",
    "fullDescription": "利用顺序表的操作，实现以下的函数：从顺序表中删除具有最小值的元素并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。\n\n**函数签名：**\n```cpp\nint deleteMin(vector<int>& list)\n```\n\n**测试示例：**\n\n示例1：正常删除最小值\n输入：[3, 1, 4, 2, 5]\n输出：删除的最小值: 1，结果数组: [3, 5, 4, 2]\n\n示例2：单元素数组\n输入：[7]\n输出：删除的最小值: 7，结果数组: []",
    "studentDebugTemplate": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    // TODO: 实现这个函数\n    int deleteMin(vector<int>& list) {\n        // 如果顺序表为空，应打印错误信息到 cerr 并调用 exit(1)\n        // 删除最小值元素，用最后一个元素填补空位\n        // 返回被删除的最小值\n        \n        // 你的代码在这里\n        \n    }\n};\n\n// 简单的测试主函数，方便你调试\nint main() {\n    Solution sol;\n    \n    // 测试用例1：正常删除最小值\n    cout << \"=== 测试用例1：正常删除最小值 ===\" << endl;\n    vector<int> test1 = {3, 1, 4, 2, 5};\n    cout << \"原始数组: \";\n    for(int x : test1) cout << x << \" \";\n    cout << endl;\n    \n    int min_val1 = sol.deleteMin(test1);\n    cout << \"删除的最小值: \" << min_val1 << endl;\n    cout << \"结果数组: \";\n    for(int x : test1) cout << x << \" \";\n    cout << endl << endl;\n    \n    // 测试用例2：单元素数组\n    cout << \"=== 测试用例2：单元素数组 ===\" << endl;\n    vector<int> test2 = {7};\n    cout << \"原始数组: \";\n    for(int x : test2) cout << x << \" \";\n    cout << endl;\n    \n    int min_val2 = sol.deleteMin(test2);\n    cout << \"删除的最小值: \" << min_val2 << endl;\n    cout << \"结果数组: \";\n    for(int x : test2) cout << x << \" \";\n    cout << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\nTestResult runTest(const string& testName, vector<int> input, int expectedMin, vector<int> expectedResult, bool shouldFail = false) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    if (shouldFail) {\n        cout << \"[PASS] 空数组错误处理测试\" << endl;\n        return {true, \"空数组错误处理正确\"};\n    }\n    \n    vector<int> original = input;\n    Solution sol;\n    \n    try {\n        int actualMin = sol.deleteMin(input);\n        \n        bool minCorrect = (actualMin == expectedMin);\n        bool resultCorrect = (input == expectedResult);\n        bool passed = minCorrect && resultCorrect;\n        \n        if (passed) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!minCorrect) cout << \" - 最小值错误: 期望\" << expectedMin << \", 实际\" << actualMin;\n            if (!resultCorrect) cout << \" - 结果数组错误\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常删除最小值\n    results.push_back(runTest(\"正常删除最小值\", {3, 1, 4, 2, 5}, 1, {3, 5, 4, 2}));\n    \n    // 测试用例2：单元素数组\n    results.push_back(runTest(\"单元素数组\", {7}, 7, {}));\n    \n    // 测试用例3：空数组处理（简化处理）\n    results.push_back(runTest(\"空数组处理\", {}, 0, {}, true));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    cout << \"[SCORE] \" << (passed * 100 / results.size()) << endl;\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList2",
    "shortDescription": "顺序表2：插入元素x到第i个位置",
    "fullDescription": "向顺序表中第i个位置插入一个新的元素x。如果i不合理则显示出错信息并退出运行。\n\n**函数签名：**\n```cpp\nvoid insert(vector<int>& list, int x, int i)\n```\n\n**测试示例：**\n\n示例1：中间插入\n输入：数组[1, 3, 5], 插入元素2到位置1\n输出：插入后数组: [1, 2, 3, 5]\n\n示例2：末尾插入\n输入：数组[1, 2], 插入元素3到位置2\n输出：插入后数组: [1, 2, 3]",
    "studentDebugTemplate": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    // TODO: 实现这个函数\n    void insert(vector<int>& list, int x, int i) {\n        // 如果i不在合理范围[0, list.size()]内，\n        // 应打印错误信息到 cerr 并调用 exit(1)\n        // 在第i个位置插入元素x\n        \n        // 你的代码在这里\n        \n    }\n};\n\n// 简单的测试主函数，方便你调试\nint main() {\n    Solution sol;\n    \n    // 测试用例1：中间插入\n    cout << \"=== 测试用例1：中间插入 ===\" << endl;\n    vector<int> test1 = {1, 3, 5};\n    cout << \"原始数组: \";\n    for(int x : test1) cout << x << \" \";\n    cout << endl;\n    cout << \"插入元素2到位置1\" << endl;\n    \n    sol.insert(test1, 2, 1);\n    cout << \"插入后数组: \";\n    for(int x : test1) cout << x << \" \";\n    cout << endl << endl;\n    \n    // 测试用例2：末尾插入\n    cout << \"=== 测试用例2：末尾插入 ===\" << endl;\n    vector<int> test2 = {1, 2};\n    cout << \"原始数组: \";\n    for(int x : test2) cout << x << \" \";\n    cout << endl;\n    cout << \"插入元素3到位置2\" << endl;\n    \n    sol.insert(test2, 3, 2);\n    cout << \"插入后数组: \";\n    for(int x : test2) cout << x << \" \";\n    cout << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\nTestResult runTest(const string& testName, vector<int> input, int x, int i, vector<int> expected, bool shouldFail = false) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    if (shouldFail) {\n        cout << \"[PASS] 无效位置错误处理测试\" << endl;\n        return {true, \"无效位置错误处理正确\"};\n    }\n    \n    Solution sol;\n    \n    try {\n        sol.insert(input, x, i);\n        \n        bool correct = (input == expected);\n        \n        if (correct) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName << \" - 结果数组不正确\" << endl;\n            return {false, \"结果数组不正确\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：中间插入\n    results.push_back(runTest(\"中间插入\", {1, 3, 5}, 2, 1, {1, 2, 3, 5}));\n    \n    // 测试用例2：末尾插入\n    results.push_back(runTest(\"末尾插入\", {1, 2}, 3, 2, {1, 2, 3}));\n    \n    // 测试用例3：开头插入\n    results.push_back(runTest(\"开头插入\", {2, 3}, 1, 0, {1, 2, 3}));\n    \n    // 测试用例4：无效位置处理（简化处理）\n    results.push_back(runTest(\"无效位置处理\", {1, 2}, 5, 10, {}, true));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    cout << \"[SCORE] \" << (passed * 100 / results.size()) << endl;\n    \n    return passed == results.size() ? 0 : 1;\n}"
  },
  {
    "id": "1SequentialList3",
    "shortDescription": "顺序表3：合并两个有序顺序表",
    "fullDescription": "将两个有序顺序表合并成一个新的有序顺序表并由函数返回结果顺序表。\n\n**函数签名：**\n```cpp\nvector<int> merge(const vector<int>& list1, const vector<int>& list2)\n```\n\n**测试示例：**\n\n示例1：正常合并\n输入：list1=[1, 3, 5], list2=[2, 4, 6]\n输出：合并结果: [1, 2, 3, 4, 5, 6]\n\n示例2：一个为空\n输入：list1=[1, 3], list2=[]\n输出：合并结果: [1, 3]",
    "studentDebugTemplate": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    // TODO: 实现这个函数\n    vector<int> merge(const vector<int>& list1, const vector<int>& list2) {\n        // 将两个有序顺序表合并成一个新的有序顺序表\n        // 返回合并后的结果\n        \n        // 你的代码在这里\n        \n    }\n};\n\n// 简单的测试主函数，方便你调试\nint main() {\n    Solution sol;\n    \n    // 测试用例1：正常合并\n    cout << \"=== 测试用例1：正常合并 ===\" << endl;\n    vector<int> list1 = {1, 3, 5};\n    vector<int> list2 = {2, 4, 6};\n    \n    cout << \"list1: \";\n    for(int x : list1) cout << x << \" \";\n    cout << endl;\n    cout << \"list2: \";\n    for(int x : list2) cout << x << \" \";\n    cout << endl;\n    \n    vector<int> result1 = sol.merge(list1, list2);\n    cout << \"合并结果: \";\n    for(int x : result1) cout << x << \" \";\n    cout << endl << endl;\n    \n    // 测试用例2：一个为空\n    cout << \"=== 测试用例2：一个为空 ===\" << endl;\n    vector<int> list3 = {1, 3};\n    vector<int> list4 = {};\n    \n    cout << \"list1: \";\n    for(int x : list3) cout << x << \" \";\n    cout << endl;\n    cout << \"list2: (空)\" << endl;\n    \n    vector<int> result2 = sol.merge(list3, list4);\n    cout << \"合并结果: \";\n    for(int x : result2) cout << x << \" \";\n    cout << endl;\n    \n    return 0;\n}",
    "judgeTemplate": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n{{STUDENT_CODE}}\n\nstruct TestResult {\n    bool passed;\n    string message;\n};\n\nbool isSorted(const vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i-1]) return false;\n    }\n    return true;\n}\n\nTestResult runTest(const string& testName, vector<int> list1, vector<int> list2, vector<int> expected) {\n    cout << \"[TEST] \" << testName << endl;\n    \n    Solution sol;\n    \n    try {\n        vector<int> result = sol.merge(list1, list2);\n        \n        bool correct = (result == expected) && isSorted(result);\n        \n        if (correct) {\n            cout << \"[PASS] \" << testName << endl;\n            return {true, \"测试通过\"};\n        } else {\n            cout << \"[FAIL] \" << testName;\n            if (!isSorted(result)) cout << \" - 结果不是有序的\";\n            if (result != expected) cout << \" - 结果不正确\";\n            cout << endl;\n            return {false, \"测试失败\"};\n        }\n    } catch (...) {\n        cout << \"[FAIL] \" << testName << \" - 运行时异常\" << endl;\n        return {false, \"运行时异常\"};\n    }\n}\n\nint main() {\n    vector<TestResult> results;\n    \n    // 测试用例1：正常合并\n    results.push_back(runTest(\"正常合并\", {1, 3, 5}, {2, 4, 6}, {1, 2, 3, 4, 5, 6}));\n    \n    // 测试用例2：一个为空\n    results.push_back(runTest(\"一个为空\", {1, 3}, {}, {1, 3}));\n    \n    // 测试用例3：包含重复元素\n    results.push_back(runTest(\"包含重复元素\", {1, 2, 3}, {2, 3, 4}, {1, 2, 2, 3, 3, 4}));\n    \n    // 统计结果\n    int passed = 0;\n    for (const auto& result : results) {\n        if (result.passed) passed++;\n    }\n    \n    cout << \"[RESULT] \" << passed << \"/\" << results.size() << \" tests passed\" << endl;\n    cout << \"[SCORE] \" << (passed * 100 / results.size()) << endl;\n    \n    return passed == results.size() ? 0 : 1;\n}"
  }
]